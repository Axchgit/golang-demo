package main

import (
	"fmt"
	"unsafe"
)

func main() {

	// 指针问题：先搞清三个概念的关系
	// 内存 = 能存数据的一块空间（想象成一间“格子”）
	// 地址 = 这个格子的“门牌号”，用来找到这间格子（内存）
	// 值   = 格子里实际存着的东西
	// 关系：每个变量（如 a）占一块内存，这块内存有个地址；地址→找到内存→内存里放着值
	// 补充：内存是实际存储的概念（物理/逻辑上的一块空间）；*b 是代码里的“写法”，用来表示“对 b 指向的那块内存做读/写”，是语法上的记号，方便我们操作那块内存
	a := 10
	// b := &a：& 取 a 的地址；b 是指针，b 里存的是“a 所在格子的门牌号”（即 a 的地址）
	b := &a
	fmt.Println(b, *b)

	// --- 下面这行 *b = 20 的完整理解 ---
	// 1) b 是指针：b 里存的是“a 的地址”（门牌号），不是 a 的值
	// 2) *b：* 表示“按这个门牌号找到那间格子（那块内存）”；读 *b = 看格子里是啥（即 a 的值），写 *b = 往格子里放东西（改 a）
	// 3) *b = 20：按 b 里的地址找到 a 的格子，把 20 写进去，a 就变成 20
	*b = 20
	fmt.Println(a, b, *b)

	// var p *int
	p := &a
	*p = 100

	fmt.Println(a, p, *p)

	// --- 改 b（改地址）能不能指向别的内存？---
	// 可以：让 b 改存“别的变量的地址”，就相当于访问别的内存块。例如：
	c := 99
	b = &c          // b 里现在存的是 c 的地址（门牌号换了），b 指向 c 那块内存
	fmt.Println(*b) // 99，访问的是 c 的值
	*b = 88
	fmt.Println(c) // 88，改的是 c
	// 不可以：不能把 b 设成“随便一个数字当地址”（例如 b = 0x12345），去访问任意内存。
	// 也不可以：对 b 表示的地址做加减（指针运算，如 b+1、b--），Go 里普通指针不支持这种操作。
	// 以上两种“乱指/乱算地址”都要用 unsafe 包（unsafe.Pointer、uintptr 等）才能做，一般业务代码不写。

	// --- 用 unsafe 对地址做加减的示例（仅作理解用，实际很少写）---
	// 说明：即使用 unsafe，能操作的也只是“本进程的地址空间”；更常说“地址空间”而不是“地址域”。
	// 无法通过改指针/unsafe 直接访问“系统里别的程序”的数据：每个进程有独立的虚拟地址空间，OS 做隔离；
	// 你手里的地址都是本进程的虚拟地址，指到别的进程会无效或崩溃。要读/写别的进程内存，必须用 OS 提供的接口
	//（如 Linux 的 /proc/<pid>/mem、ptrace，Windows 的 ReadProcessMemory），不是在本进程里算地址就能做到。
	// 数组里两个 int 在内存里挨着；从第一个元素的地址 + 一个 int 的大小 = 第二个元素的地址
	arr := [2]int{11, 22}
	p0 := &arr[0]                       // 第一个元素的指针
	addr := uintptr(unsafe.Pointer(p0)) // 指针 → 可做整数运算的“地址”
	addr += unsafe.Sizeof(arr[0])       // 地址 + 一个 int 的字节数，得到下一个元素地址
	p1 := (*int)(unsafe.Pointer(addr))  // 再转回 *int，现在 p1 指向 arr[1]
	fmt.Println(*p0, *p1)               // 11 22
	*p1 = 99
	fmt.Println(arr) // [11 99]

	fmt.Println(**&p1)

	p2 := &p1 // p2 是 **int
	p3 := &p2 // p3 是 ***int
	p4 := &p3 // 只能一层层写：& 的左边必须是“变量”等可寻址对象，不能写 &&&&&&p3（&p3 的结果不能再取地址）
	fmt.Println(p4)
	fmt.Println(*p4)
	fmt.Println(**p4)
	fmt.Println(***p4)
	fmt.Println(****p4)
}
